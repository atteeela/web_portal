require 'dns_util'

class Hostname
  include Mongoid::Document
  include Mongoid::Timestamps

  field :name, type: String
  field :origin, type: String
  field :version, type: Integer
  field :cname, type: String
  field :valid_origin_ips, type: Array    #Each IP maps to a backend in VCL, it must match when we resolve the origin name

  embeds_one :hostname_status

  belongs_to :account, :index=>true
  belongs_to :ruleset, :index=>true, :inverse_of => :ruleset
  belongs_to :active_ruleset, :class_name => "Ruleset", :index => true, :foreign_key => "active_ruleset_id", :inverse_of => :ruleset
  #belongs_to :pending_ruleset, :class_name => "Ruleset", :index => true, :foreign_key => "ruleset_id", :inverse_of => :ruleset

  index :name=>1
  index "hostname_status.host"=>1

  attr_protected :cname  #CNAME MUST BE GENERATED BY US !!! 

  # TODO - REMOVE PENDING
  scope :ready_for_vcl, where(:name.ne=>nil).in("hostname_status.host"=> ["ACTIVE","READY","PENDING"])
  #scope :active, where("hostname_status.host" => "ACTIVE")

  before_validation(:on=>:create) do 
    validate_package
    set_hostname
    set_origin
    set_cname
    set_valid_origin_ips
    set_status
    validate_ruleset_status
  end

  before_validation(:on=>:update) do
   # unless self.hostname_status
      set_status
      validate_origin
      set_valid_origin_ips
      validate_ruleset_status
   # end
  end

  before_destroy :prepare_for_destroy
  after_save :activate_ruleset
  after_create :create_dns_entry
  
  validates :name, :presence=>true, :uniqueness=>true, :format => { :with => /[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/, :message => "Invalid hostname format"}
  validates :origin, :presence=>true
  validates :cname, :presence=>true
  validates :ruleset_id, :presence=>true

  

  def has_tokens?
    false #self.account.security_tokens.count > 0
  end

  def valid_for_vcl?
    !self.active_ruleset.nil? && !self.lb_vip.nil?
  end

  def new_config_valid_for_vcl?
    !self.lb_vip.nil?
  end

  def status
    self.hostname_status.host
  end

  def active?
    self.hostname_status.host=="ACTIVE"
  end

  def cname_active?
    self.hostname_status.cname=="ACTIVE"
  end

  def origin_active?
    self.hostname_status.origin == "ACTIVE"
  end

  def has_active_ruleset?
    !self.active_ruleset.nil?
  end

  def resolved?
    self.hostname_status.cname == "RESOLVED"
  end

  def activate
    self.hostname_status.update_attribute(:host,$HOSTNAME_STATUS[:active])
    DnsMailer.hostname_active(self.account.user.email,self).deliver
    return true
  end

  def active
    self.where("hostname_status.host" =>'ACTIVE')
  end

  def pending
    self.where("hostname_status.host" =>'PENDING')
  end

  def set_active_ruleset(ruleset)
    Rails.logger.info("Deactivating Previous Ruleset" + self.ruleset.id.to_s)
    self.active_ruleset.deactivate if self.has_active_ruleset?
    self.update_attribute(:active_ruleset_id, self.ruleset_id)
  end

  def reset_pending_ruleset
    return unless self.active_ruleset
    self.update_attribute(:ruleset_id, self.active_ruleset_id)
  end

 private

  # TODO
  def create_dns_entry
    msg = { :action => "create_hostname", :payload => { :hostname => self.name, :id => self.id } }.to_json
    MqLib.publish(msg,'jobs.hostname')
    DnsMailer.hostname_created(self.account.user.email,self).deliver
  end

  #-----------------------------------------------
  # We need to lookup the hostname and its CNAMEs
  # to make sure it does not resolve to AWS ELB
  # 
  # Right now we can not create "dynamic" backends
  # which is what ELB is , so... we have a problem
  #-----------------------------------------------
  

  def invalid_origin?
    if DnsUtil.origin_aws_elb?(self.origin)
      self.errors.add(:base,"Sorry, Amazon AWS Elastic Load Balancers are currently not supported as origin servers")
      return true
    end

    # no letters means an ip address so lets validate it
    if self.origin.match(/[a-zA-Z]/).nil? && !IPAddress.valid?(self.origin)
      self.errors.add(:base, "Sorry you used an invalid IP Address format for your origin")
      return true
    end

    false
  end

  def set_origin
    self.origin = self.origin.blank? ? "origin." + self.name : self.origin.gsub(/http\:\/\/|https\:\/\//,"")
    return false if invalid_origin?
  end

  def set_hostname
    if self.name
      self.name = self.name.gsub(/http\:\/\/|https\:\/\//,"") 
      self.name = self.name.gsub(/\/.*$/,'')
      self.name = self.name.downcase
    end
    return true
  end

  def set_cname
    self.cname = self.name+"."+$CNAME_SUFFIX
  end
  
  def set_status
    self.build_hostname_status
  end

  #---------------------------------------------------------
  # In varnish we want to use DNS backends.  Each valid_origin_ip
  # will ultimately become a valid backend for this hostname.
  # To do this we need to pre-create a backend
  # for every valid IP that a customer origin can resolve to.  
  # Since some customers use
  # GSLB or failover we may not know all the ips upfront. 
  # This allows us to ensure if they failover DNS we can 
  # address the situation and not try a down host.
  #---------------------------------------------------------
  def set_valid_origin_ips
    ips = Array.new

    if !self.valid_origin_ips.nil?
      self.valid_origin_ips.each { |ip|
        if !ip.match(/^(\d+\.){3}\d+$/)
          self.errors.add(:base,"Invalid IP address format specificed in Additional Valid IPs")
          return false
        end
        ips << ip
      }
    end

    if (extra_ips = DnsUtil.lookup_arecs(self.origin)) != false 
     ips = ips + extra_ips
     self.valid_origin_ips = ips.uniq
    else
      self.errors.add(:base,"Sorry unable to validate additional ips")
      false
    end
  end

  def validate_origin
    invalid_origin?
  end

  def validate_ruleset_status
    return false unless self.ruleset
    errors.add(:base,"Sorry you can not assign a ruleset with an invalid status") and return false if self.ruleset.is_invalid?
    true
  end


  # TODO
  def validate_package
    # return true
    # #unless self.account.hostnames.count >= self.account.max_hostnames
    # #  return true
    # #end
    if self.account.hostnames.count >= self.account.max_hostnames
    self.errors.add(:base, "You have exceeded the number of authorized hostnames for this account.  Either remove one of your hostnames or ask your site administrator to upgrade the packages for this account.")
    return false
    end
    true
  end

  def prepare_for_destroy
    return true #unless self.hostname_status
    if ["ACTIVE","READY"].include? self.status
      self.hostname_status.host="PENDING_REMOVAL"
      self.errors.add(:base, "Hostname was in a 'READY' or 'ACTIVE' state.  Deactivation has been scheduled.")
      return false
    end
    return true
  end

  def activate_ruleset
    return unless self.new_record? || self.ruleset_id_changed? || self.hostname_status.host_changed?
    Rails.logger.info("Activating ruleset with id " + self.ruleset.id.to_s)
    self.ruleset.publish_ruleset(self.id)
  end


end
